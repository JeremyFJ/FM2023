---
title: "Population dynamics, CPUEs, and Catch Curves"
author: "(Your name here)"
date: "2/9/23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
lab_path = dirname(rstudioapi::getSourceEditorContext()$path)
knitr::opts_knit$set(root.dir = lab_path)
getwd()
set.seed(9999)
```

You will need the following packages installed and loaded. 
```{r message=FALSE}
library(tidyverse)
library(magrittr)
library(FSA)
library(FSAdata)
library(rfishbase)
```  

# Population Dynamics

## Exponential Growth model
$$
N_t = N_0e^{(b-d)t}
$$
`Nt` = population size at time
`N0` beginning population size
`b` = birth rate
`d` = death rate
`t` = time

Exponential growth of a hypothetical population using different birth and death rates.
```{r examplebox2.1}
b = c(0.2,0.2,0.2) # birth rates
d = c(0.04,0.1,0.2) # death rates
N0 = c(500,500,500) # starting populations

Time = seq(0,20,0.5) # time steps
Nt = matrix(NA, nrow = length(Time), ncol = 3)
for (i in 1:3){
  Nt[,i] = N0[i]*exp((b[i]-d[i])*Time)
}

Nt_dat = data.frame(Nt)
colnames(Nt_dat) = c('T1', 'T2', 'T3')
ggplot() + geom_line(aes(x=Time, y=Nt_dat$T1)) +
  geom_line(aes(x=Time, y=Nt_dat$T2),col=2) +
  geom_line(aes(x=Time, y=Nt_dat$T3), col=3) + 
  labs(x="Time", y="Population size (Nt)")
```

## Logistic Population Growth

$$
N_{t+1} = N_t + rN_t(1-N_t/K) - C_t 
$$
`Nt+1` = population size at timestep t+1
`Nt` = population size at time
`r` = rate of increase
`K` = carrying capacity
`C_t` = harvest rate  

```{r}
colors = c("0"="grey76", "10"="grey60", "20"="black")
r = 0.5
K = 1000
N0 = 50
Time = seq(0,25,1)
Nt = c()
Nt[1] = N0
#-----------------------
# Catch = 0
#-----------------------
for (i in 1:25){
  Nt[i+1] = Nt[i] + r*Nt[i]*(1-Nt[i]/K)
}
Nt0 = Nt
Ct = 10
#-----------------------
# Catch = 10
#-----------------------
for (i in 1:25){
  Nt[i+1] = Nt[i] + r*Nt[i]*(1-Nt[i]/K) - Ct
}
Nt1 = Nt
Ct = 20
#-----------------------
# Catch = 20
#-----------------------
for (i in 1:25){
  Nt[i+1] = Nt[i] + r*Nt[i]*(1-Nt[i]/K) - Ct
}
Nt2 = Nt

ggplot() + 
  geom_line(aes(x=Time, y=Nt0, color="0"), size=1.5) +
  geom_line(aes(x=Time, y=Nt1, color="10"), size=1.5) +
  geom_line(aes(x=Time, y=Nt2, color="20"), size=1.5) + 
  labs(x="Time", 
       y="Population size",
       color="Catch") +
    scale_color_manual(values = colors)
```
  
Now we look at intrinsic growth rates > 1 which should lead to unstable and oscillatory population dynamics. 
```{r fig2.6}
r = 0.25
K = 1000
N0 = 1
Time = seq(0,100,1)
Nt = c()
Nt[1] = N0
Ct = 0
for (i in 1:100){
  Nt[i+1] = Nt[i] + r*Nt[i]*(1-Nt[i]/K) - Ct
}
par(mfrow  = c(2,2))
plot(Nt~Time, type = "l", ylim = range(Nt), main="r=0.25")
r = 1.85
for (i in 1:100){
  Nt[i+1] = Nt[i] + r*Nt[i]*(1-Nt[i]/K) - Ct
}
plot(Nt~Time, type = "l", ylim = range(Nt), main="r=1.85")
r = 2.5
for (i in 1:100){
  Nt[i+1] = Nt[i] + r*Nt[i]*(1-Nt[i]/K) - Ct
}
plot(Nt~Time, type = "l", ylim = range(Nt), main="r=2.5")
r = 3
for (i in 1:100){
  Nt[i+1] = Nt[i] + r*Nt[i]*(1-Nt[i]/K) - Ct
}
plot(Nt~Time, type = "l", ylim = range(Nt), main="r=3")
```

### Predicting growth rate of a population
*Parameters that we need*
- Lifespan
- Fecundity
- Age at Maturation
```{r}
# ---- Mortality rate ----------------------------

# get mortality from Then.etal.2014
getMtmax = function(lifespan){		
		M = 4.899 * lifespan^-0.916
		M
}

# get mortality using Dulvy.etal.2004's method
getMDulvy.etal.2004 = function(lifespan, agemat){
	w = (lifespan+agemat)/2 # average lifespan
	M = 1/w
	M
}

getRmax= function(method = "Smith.etal.1998", mortality = "Then.etal.2014", fec = NULL, litter = NULL, cycle = NULL, lifespan, agemat){

  # Calculate natural mortality rate
	if (mortality== "Dulvy.etal.2004") M = getMDulvy.etal.2004(lifespan = lifespan, agemat = agemat)
	if (mortality== "Then.etal.2014") M = getMtmax(lifespan = lifespan)
	if (is.numeric(mortality)) M = mortality

	if(method=="Smith.etal.1998"){
		tmax = lifespan
		tmat = agemat
		if (is.null(fec)) fec = litter/2/cycle else fec = fec
		Z<-1.5*M
	
		#this is equation 7 in the manuscript
		l_alpha<-(1-exp(-(Z)))/((fec)*(1-exp(-(Z*(tmax-tmat+1)))))

		#this is equation 6 in the manuscript
		eq6 <- function(reb) 1-exp(-(M+reb))-l_alpha*(fec)*1.25*exp(-reb*tmat)*(1-exp(-(M+reb)*(tmax-tmat+1)))
		r_Z<-uniroot(eq6, c(0,5), tol=1e-8)
		return(r_Z$root*2)
	} 
	
}
```

Look at Spiny Dogfish in the Northwest Atlantic.
```{r}
spinyLife = popgrowth(species_list = c("Squalus acanthias"))
```

```{r}
spinyLife = subset(popgrowth(species_list = c("Squalus acanthias")), Locality=="Northwestern Atlantic")
spinyFec = fecundity(species_list = c("Squalus acanthias"))[1,]
spinyMat = subset(maturity(species_list = c("Squalus acanthias")), Locality=="Northwest Atlantic")
```

Calculate growth rate for Northwest Atlantic spiny dogfish stock
```{r}
lifespan = mean(spinyLife$tmax, na.rm=T)
fecundity = (spinyFec$FecundityMin+spinyFec$FecundityMax) / 2 # mean of minimum and maximum fecundity
agemat = (spinyMat$AgeMatMin + spinyMat$AgeMatMin2) / 2 # mean of two records for minimum age at maturity
rmax = getRmax(method = "Smith.etal.1998", mortality = "Then.etal.2014", fec = fecundity, lifespan = lifespan, agemat = agemat)
paste0("Intrinsic Growth Rate = ", round(rmax, 3))
```

## Calculating CPUEs
Catch and effort of swordfish by longline in the Pacific Ocean by the Inter-American Tropical Tuna Commission and the Western Pacific Fisheries Commission. These are RFMOs or Regional Fisheries Management Organization. 
```{r}
iattc = read.csv("iattc_swo.csv") # IATTC catch and effort for swordfish
wcpfc = read.csv("wcpfc_swo.csv") # WCPFC catch and effort for swordfish
```

### Creating CPUEs from catch and hook data 
Create catch per unit effort using the `catch` and `hooks` columns 

```{r}
# calculate CPUE 
iattc$cpue = (iattc$catch / iattc$hooks)*1000
wcpfc$cpue = (wcpfc$catch / wcpfc$hooks)*1000
```

## Total Catch by Nation

Now that we have comprehensive CPUEs from two data sources we can do a more-informed stock assessment of swordfish in the Pacific Ocean

Next, let's look at recent catch biomass by country for IATTC and WCPFC reports. 
```{r}
p1 = ggplot(aes(y = log(cpue), x = fleet), data = iattc) + 
  geom_boxplot() +
  ggtitle("IATTC")
p2 = ggplot(aes(y = log(cpue), x = fleet), data = wcpfc) + 
  geom_boxplot() +
  ggtitle("WCPFC") 

gridExtra::grid.arrange(p1,p2)
```

```{r}
# IATTC
fleet_ia = aggregate(data=iattc, catch~fleet, sum) # aggregate catch by fleet
top5fleets_ia <-  fleet_ia[order(-fleet_ia$catch),] # order fleet by top catches
top5fleets_ia <- top5fleets_ia[c(1:5),] #isolate top 5
top5_iattc <- subset(iattc, year >= 1990) %>% #only consider 1990 forward
  filter(fleet %in% top5fleets_ia$fleet) # top fleets with most catch
iattc_plot = ggplot(top5_iattc, aes(fill=fleet, y=catch*0.001, x=year)) + 
  geom_bar(position="stack", stat='identity') + ggtitle("IATTC Swordfish") + 
  ylab("Catch (t)")

# WCPFC
fleet_wc = aggregate(data=wcpfc, catch~fleet, sum) # aggregate catch by fleet
top5fleets_wc =  fleet_wc[order(-fleet_wc$catch),] # order fleet by top catches
top5fleets_wc <- top5fleets_wc[c(1:5),] #isolate top 5
top5_wcpfc <- subset(wcpfc, year >= 1990) %>% #only consider 1990 forward
  filter(fleet %in% top5fleets_wc$fleet) # top fleets with most catch
wcpfc_plot = ggplot(top5_wcpfc, aes(fill=fleet, y=catch*0.001, x=year)) + # top fleets with most catch
    geom_bar(position="stack", stat="identity") + ggtitle("WCPFC Swordfish") +
  ylab("Catch (t)")

```

```{r}
gridExtra::grid.arrange(iattc_plot, wcpfc_plot) # arrange both plots next to each other
```

### Identify Stocks
From the 2018 WCPFC assessment, there appears to be 3 defined stocks of Pacific Swordfish, delineated by the equator and the 150W longitude line. 

Look at the `North` and `South` swordfish stocks in the Western Pacific
```{r}
dat_n = wcpfc[wcpfc$lat>0,] # subset master dataframe for ABOVE the equator
fc_north = aggregate(data=dat_n, catch~year, FUN=mean) # aggregate catch by year
fc_north$hooks = aggregate(data=dat_n, hooks~year, FUN=mean)$hooks # add aggregated hook data
fc_north$cpue = fc_north$catch/fc_north$hooks*1000 # and finally calculate average CPUE

dat_s = wcpfc[wcpfc$lat<0,] # subset master dataframe for BELOW the equator
fc_south = aggregate(data=dat_s, catch~year, FUN=mean)
fc_south$hooks = aggregate(data=dat_s, hooks~year, FUN=mean)$hooks
fc_south$cpue = fc_south$catch/fc_south$hooks*1000
```


```{r}
north = ggplot() + 
  geom_line(data=fc_north, aes(x=year, y=cpue)) +
  ylab("CPUE (kg/hook)") +
  ggtitle("Northwest Pacific Swordfish") +
  theme(panel.grid = element_line(colour = "black",size = 0.05),
        panel.border = element_rect(fill = NA))

south = ggplot() + 
  geom_line(data=fc_south, aes(x=year, y=cpue)) +
  ylab("CPUE (kg/hook)") +
  ggtitle("Southwest Pacific Swordfish") +
  theme(panel.grid = element_line(colour = "black",size = 0.05),
        panel.border = element_rect(fill = NA))

gridExtra::grid.arrange(north, south)
```

Plot CPUEs on a map by grid
```{r}
scale_cols = c("#FFFFFF", hcl.colors(6))
world2 <- map_data("world2") #world2 is centered on antimeridian
wcpfc$lon2 <- ifelse(wcpfc$lon < 0, wcpfc$lon + 360, wcpfc$lon) #IF lon is negative, we add 360 to correct for antimeridian, ELSE means its positive so we leave it
ggplot() + 
  geom_tile(data=wcpfc, aes(x=lon2, y=lat, fill=cpue)) + #lon2 is our corrected lon
  geom_map(
    data = world2, map = world2, #world 2 is our antimeridian map
    aes(long, lat, map_id = region)) +
  scale_fill_gradientn(colours=scale_cols, 
                       breaks=c(0, 1, 2, 3), 
                       limits=c(0,3),
                       name="CPUE\n(Catch/1000 hooks)\n") +
  labs(y="Latitude") + #Rename y axis
  scale_x_continuous(name="Longitude", breaks=c(0,90,180,270), labels=c(0,90,180,-90)) #Correct longitude to show negative values
```

## Length-Frequency Distribution, Catch Curves, and Total Mortality

Yellow Perch FSA data from Trout Lake Wisconsin
```{r}
perch = YPerchTL
headtail(perch)
```

```{r}
perch2000 <- filter(perch,year4==2000)
perch2001 <- filter(perch,year4==2001)
perch2002 <- filter(perch,year4==2002)

perch2000 %<>% mutate(lcat10=lencat(length,w=10)) # the appropriate 10 mm length interval for yellow perch
perch2001 %<>% mutate(lcat10=lencat(length,w=10))
perch2002 %<>% mutate(lcat10=lencat(length,w=10))
headtail(perch2000)
( bgFreq10 <- xtabs(~lcat10,data=perch2000) )
```

```{r}
par(mfrow=c(1,2))
hist(~length,data=perch2000, xlab="Total Length (mm)", col = "black", main="2000")
hist(~length,data=perch2001, xlab="Total Length (mm)", col = "black", main="2001")
```

Plot empirical cumulative distribution function (ECDF) which is the proportion of fish
that are less than each observed length.
```{r}
clr <- c("black","gray55")
plot(ecdf(perch2000$length),xlab="Total Length (mm)",do.points=FALSE,
verticals=TRUE,main="",col.01line=NULL)
plot(ecdf(perch2001$length),add=TRUE,do.points=FALSE,
verticals=TRUE,col=clr[2],col.01line=NULL)
legend("bottomright",c("2000","2001"),col=clr,lty=1,
bty="n",cex=0.75)
```


### Catch-at-Age

Look at catches-at-age of Brook Trout captured in Tobin Harbor (Michigan) from
1996–1998 (Quinlan 1999).
```{r}
bkt <- data.frame(age=0:6,ct=c(39,93,112,45,58,12,8))
ggplot() + 
  geom_point(data=bkt, aes(x=age, y=log(ct)), pch=19) + 
  xlab("Age (years)") + 
  ylab("Log Catch") + 
  theme_bw()
```

Compute estimates of annual survival rate ($S$), annual mortality rates ($A$), and instantaneous mortality rate ($Z$)
```{r}
thcr <- chapmanRobson(ct~age,data=bkt,ages2use=0:6)
cbind(summary(thcr),confint(thcr))
```

```{r}
plot(thcr)
```

```{r}
tmp <- filter(bkt,age>=2) %>% mutate(lnct=log(ct)) # filter for ages >2 and log catch
lm1 <- lm(lnct~age,data=tmp) # linear regression
coef(lm1)
```

Assuming that mortality is constant, ages 0-1 will not be considered fully recruited.
```{r}
thcc <- catchCurve(ct~age,data=bkt,ages2use=2:6,weighted=TRUE)
cbind(summary(thcc),confint(thcc))
plot(thcc,pos.est="bottomleft", main="Predicted log catch and mortality of Florida Largemouth Bass")
```

The catch curve methods make the following assumptions:

1. The population is closed to emigration and immigration.
2. Recruitment is constant among years (if cross-sectional data are used or if estimates from longitudinal data will be extended to other year-classes).
3. `Z` is constant across ages and years for ages on the descending limb of the catch curve.
4. Vulnerability (if catch data are used) and catchability (if CPUE data are used) of the fish is constant across ages and years for ages on the descending limb of the catch curve.
5. The sample is not biased regarding any specific age group(s).