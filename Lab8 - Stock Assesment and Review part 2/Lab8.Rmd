---
title: "Virtual Population and Stock Analyses"
author: "(Your name here)"
date: "3/16/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
lab_path = dirname(rstudioapi::getSourceEditorContext()$path)
knitr::opts_knit$set(root.dir = lab_path)
set.seed(9999)
require(TropFishR)
```


# Virtual Population Analysis (VPA)
## Statistical Catch-at-Age (SCA)

Example of using VPA for Yield-per Recruit Analyses. This is useful to understand the optimal value of fishing mortality to obtain the maximum yield or identified optimal yield. 

Project historic population trends from the oldest cohort caught in the most recent year. We use an exponential decay to model the population change from one cohort to another: 

$$
N_{t+1} = N_te^{-(F+M)}
$$

Where F and M are instantaneus rates of Fishing and Natural mortality. We can then calculate the number fish caught with the catch equation:

$$
\text{Catch}\\C_t = \frac{F_t}{F_t+M_t}N_t(1-e^{-(F+M)})\\
$$

So we assume M and F for the oldest cohort. M would be constant for all exploited cohorts while F can vary. 

Additionally, total mortality is given by:

$$
\text{total mortality}\\F_t + M_t = Z_t
$$

For example, if we assume: 
- `M = 0.2`  
- `F = 0.6` 
- `we caught x amount of fish at age = 4` 
- We can work out the population size of fish at age = 4 by rearranging the catch eq.

$$
N_t = \frac{C_t}{(F_t/Z_t)(1-e^{-Z_t})}\\t=3
$$

Generate catch data for 4 years
```{r}
C = runif(4, min=30, max=100) # generates 4 random catch values 
C
```

Calculate population size with mortality, catch, and age
```{r}
M = 0.2 # Natural Mortality rate (assuming constant)
Fi = rep(0,4) # Fishing Mortality rate (assuming changes every year)
Fi[4] = 0.6
Z = Fi[4] + M # Total Mortality rate
N = rep(0,4) # Population size for each year

N[4] = C[4] / ((Fi[4]/Z)*(1-exp(-Z))) # Calculate population size at t=4
N
```

To populate the amount of fish for the previous year, we must calculate $F_{t-1}$ or $F_{[3]}$ in this case.

```{r}
Fi
```

$$
C_{t-1} = \frac{F_{t-1}}{F_{t-1}+M}N_t(e^{(F_{t-1}+M)}-1)
$$

Define a function to calculate the above catch equation
```{r}
step2fun = function(x, N, C){
  
	(x/(x+M)*N*(exp(x+M)-1)) - C
  
}
```

Solve for root of the function where Catch = catch[t-1] based on the current pop size. 
```{r}
Fi[3] = uniroot(step2fun, N = N[4], C = C[3], interval = c(0,2))$root # uniroot finds the root of the function 
Fi
```

Then we use fishing mortality to calculate population size again.
$$N_{t-1} = N_te^{(F_{t-1}+M)}$$

```{r}
N[3] = N[4]*exp(Fi[3]+M)
N
```

Finish the population analysis
```{r}
Fi[2] = uniroot(step2fun, N = N[3], C = C[2], interval = c(0,2))$root
N[2] = N[3]*exp(Fi[2]+M)

Fi[1] = uniroot(step2fun, N = N[2], C = C[1], interval = c(0,2))$root
N[1] = N[2]*exp(Fi[1]+M)
N
```

## Exercise
### North Sea whiting
Use this dataset of North Sea whiting (Merlangius merlangus) that were caught from 1974-1980 to simulate population size for each age class. Catch at age was recorded for whiting (0-7+ years old).
```{r}
data(whiting)
```

```{r}
M = 0.2 # natural mortality rate
Fi = rep(0,8) # empty vector for fishing mortality
Fi[8] = 0.2 # fishing mortality rate when t=8
Z = M + Fi[8] # total mortality rate
C = whiting$catch[,1] # catch in 1974 for 8 age classes
N = rep(0,8) # empty vector for population size
```

Calculate the final N (when t=8) 
```{r}

```

Write a `for loop` to calculate population size for each age class
**hint** use `uniroot` and the `population equation` to work backwards through age
```{r}

```

```{r}
output <- VPA(param = whiting, catch_columns = 1, terminalE = 0.5, analysis_type = "VPA")
plot(output)
```

### Senegalese hake
This dataset contains length-frequency data and biological characteristics about hake (Merluccius merluccius) and its fisheries off Senegal.
```{r}
data(hake)
hake
```

Calculate the population of each size class. Define `M, F, Z, and catch`
**hint** first calculate the population of the oldest size class and work backwards
```{r}

```

```{r}
VPA(hake, terminalE = 0.5, analysis_type = "VPA", plot = TRUE,
catch_unit = "'000", plus_group = TRUE)
```


# Yield-per-Recruit
The following script has been developed from Box 7.6 of Chapter 7 in [@Jennings.etal.2009].

Recruitment is constant, so the structure of a population is the same as if we would see from following a single cohort. Yield is measured per recruit. F and M are also constant after recruitment (the moment they become vulnerable to the fishery). It assumes stable age structure through time. Ignore impact of fishing mortality on recruitment.
```{r expDec}
par(mfrow=c(1,2))
N0 = 100 # number of individual at age 1
years = 1:10 # follow the cohort for 10 years
Fi = 0.6 # fishing mortality
M = 0.2 # natural mortality
Z = Fi+M # total mortality
Nt = c(N0,N0*exp(-(Fi+M)*years[1:9])) # calculate numbers in following ages assuming a exponential decay
plot(Nt~years, type = "l")
barplot(Nt~years)
```

## Exercise
Calculate `Catch` in number for each year using  
$$
C_t = \frac{F}{Z}N_t(1-e^{-Z})
$$

```{r catch}

```

$$
\text{YPR = }
\frac{\sum{CW}}{N_0}
$$

$$
\text{BPR = }
\frac{\sum{N_tW}}{N_0}
$$

Calculate YPR and BPR
```{r}
W = c(0.6,0.9,2.1,4.1,6.3,8.4,10,11.2,12.6,13.5) # these are average weights at age

```

Lastly, plot historical population sizes considering 3 different values of total mortality (Z)
$$
N_t = N_0e^{-Zt}
$$

```{r}
Z = c(0.1, 0.3, 0.9)

```

Now let's calculate Yield-per-recruit for a range of different fishing mortalities. Let's write a function which repeat the steps above
```{r YpR}
getYpR = function(Fi){
  N0 = 100
  years = 1:10

  M = 0.2
  Z = Fi+M
  Nt = c(N0,N0*exp(-(Fi+M)*years[1:9]))
W = c(0.6,0.9,2.1,4.1,6.3,8.4,10,11.2,12.6,13.5)
Pb = Nt*W # Population biomass
Cn = Fi/(Z)*Nt*(1-exp(-Z)) # catches in Numbers
Cw = Cn*W
Y = sum(Cw)

# Yield per recruit
YpR = Y/N0
# Biomass per recruit
BpR = sum(Pb)/N0
c(YpR = YpR,BpR = BpR)
}  
```

Now we need to assign a sequence of values to fishing mortality.
`do.call()` executes a function defined as an argument. In this case, we can specify 2 functions, one that combines matrices or dataframes `rbind()` created by calculating Yield-per-Recruitement per fishing mortality Fis with `lapply()` 
```{r}
Fis = seq(0,1,.1) # range of fishing mortality values 

dat = do.call(rbind, lapply(Fis, getYpR)) # apply the function to all elements of Fis and then combine the results in a table
dat = as.data.frame(dat) # we need to make sure this table is a data.frame
dat$Fi = Fis

par(mar = c(5,5,2,5)) # set the margins for the plotting device
plot(YpR~Fi, dat, type = "l", axes = FALSE, ylab = "Yield per Recruit (kg)")
axis(1)
axis(2)
par(new = T) # allows overplotting on the same figure
plot(BpR~Fi, dat, type = "l", lty = 2, axes=FALSE, xlab=NA, ylab=NA, ylim = c(0,20)) # this is the dashed line
axis(side = 4)
mtext(4,line = 3 ,text = "Biomass per Recruit (kg)")
# best Fi
abline(v = dat$Fi[dat$YpR==max(dat$YpR)], lty = 2)
text(0.33, 0.1, expression('Fi at max YpR'))
text(0.8,0.4, expression('BpR'))
text(0.8,10, expression('YpR'))
```
So fishing harder does not generate more Yield per recruit. The optimal fishing mortality is 0.2.












